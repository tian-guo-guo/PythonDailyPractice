'''
求n阶方形矩阵的行列式的值

高斯消元法：
通过逐行消元，把原矩阵变换为一个上三角矩阵，最后乘起所有对角线元素，就得到矩阵行列式的值。
'''

# method 1: 高斯消元法：
# 算法如下：
# def det(n):
#     # 设被求值矩阵为二维表A[0:n][0:n]
#     for i in range(n-1):
#         # 用A[i][i]将A[i+1:n][i]的值都变为0
#     det = 0.0
#     for i in range(n):
#         det += A[i][i]
'''
最后求乘积的循环需要O(n)时间。前一步的消元循环从i等于0做到i等于n-2,对i迭代
时需要做n-i-1行的消元，在每行对n-i个矩阵元素做乘法和减法运算，总的时间开销不超
过O(n2)，因此算法的时间复杂度是0(n3)。
'''

# method 2: 基于矩阵行列式的定义
'''
这个算法是递归的，为计算n阶方阵的行列式时需要算出n个n-1阶的行列式，
每计算一个n-1阶行列式需要算出n-1个n-2阶的行列式....因此有下面推导:
T(n)=nX((n-1)^2+ T(n-1) > nXT(n-1) > nX(n- 1)XT(n- 2)>0(n!)
其中的平方项表示构造低阶矩阵的开销。复杂度O(n!)比0(n2)增长得快得多，因此这个算法
的复杂度极高，只能处理很小的矩阵，基本不实用。
'''
# 递归算法的模式：
# def recur(n):
#     if n == 0:
#         return g(...)
#     somework
#     for i in range(a):
#         x = recur(n/b)
#         somework
#     someword
'''
也就是说，n值为0时直接得到结果，否则原问题将归结为a个规模为n/b的子问题，其中
a和b是由具体问题决定的两个常量。另外，在本层递归中还需要做一些工作，上面描述里用
somework表示，其时间复杂度可能与n有关，设为O(n^k)。这个k也应该是常量，k=0表
示这部分工作与n无关。这样就得到了下面的递归方程:
T(n)=O(n^k)+a*T(n/b)
有如下结论:
●如果a>b^k,那么T(n)=0(n^logba)。
●如果a=b^k,那么T(n)=0(n^k*logn)。
●如果a<b^k,那么T(n)=0(n^k)。
'''
