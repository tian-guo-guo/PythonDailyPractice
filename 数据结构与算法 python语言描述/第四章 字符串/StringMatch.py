'''
字符串匹配的实际应用。例如:
●需要检索的文本可能很大，经常需要用一-个模式串在其中反复检索。
●网络搜索需要处理数以亿万计的网页，对付来源于世界各地的发生频率极高的千奇百
怪的检索需求。
●防病毒软件要在合理时间内检查数以十万计的文件(在目前的普通微机上，文件的数据
量也以GB计),而且需要同时处理- - 大批病毒特征串。
●运行在服务器上的邮件过滤程序，需要在很短的时间内扫描数以万计的邮件和附件，
用已知的或特定的一-组模式串在其中匹配，模式串的集合还经常变化。
●为了生物/疾病/药物的研究和新作物/生物品种培养等生物学工程应用，需要用大量
DNA模式与大量DNA样本(都是DNA序列)匹配。
'''

'''
朴素串匹配算法:
① 从左到右逐个字符匹配；② 发现不匹配时，转去考虑目标串里的下一个位置是否与模式串匹配
缺点：
算法的效率很低n-m+1躺比较，总比较次数为m*(n-m+1)
'''
def naive_matching(t, p):
    m, n = len(p), len(t)
    i, j = 0, 0 
    while i < m and j < n:  # i==m说明找到匹配
        if p[i] == t[j]:    # 字符相同！考虑下一对字符
            i, j = i + 1, j +1 
        else:               # 字符不同！考虑中下一位置
            i, j = 0, j - i + 1 
    if i == m:          
        return j - i    
    return -1           # 无匹配，返回特殊值

print(naive_matching('1234567', '345'))

'''
无回溯串匹配算法（KMP算法）
朴素匹配算法的缺点在于，匹配中反复使用，如果之前的匹配上了，再有没匹配上，那就做
无用功了。所以，如果先对模式串做一些分析，记录得到有用信息，就有可能避免一些不必
要的匹配提高效率。这种做法实际是匹配前的静态预处理，只需要做一次。
KMP算法不是一个一个匹配着前进，如何前两个失败，则下一次直接从第三个开始匹配。
KMP算法的基本思想是匹配中的不回溯。如果匹配中庸模式串里的pi匹配某个tj时失败了，
就找到某个特定的ki(0≤ki＜j)，下一步用模式串中字符pki与目标串里的tj比较。
也就是说，在匹配失败时把模式串前移若干位置，用模式串里匹配失败之前的某个字符与
目标串中匹配失败的字符比较。
关键点：如何确定匹配失败时模式串前移？
从上面分析中得到的结论是:对p中的每个i,都有与之对应的下标k，与被匹配的目标
串无关。有可能通过对模式串p的预分析，得到每个i对应的k, (为每个p找到与之对应的
p)。假设模式串p的长度是m,现在需要对每个i (0≤i<m)计算出对应的k,并将其保存起
来，以便在匹配中使用。为此可以考虑用一-个长为m的表pnext,用表元素pnext[i] 记录与
i对应的k值。
有点难，没看懂= = 
'''
def matching_KMP(t, p, pnext):
    '''KMP串匹配，主函数'''
    j, i = 0, 0 
    n, m = len(t), len(p)
    while j < n and i < m:      # i==m说明找到了匹配
        if i==-1 or t[j]==p[i]: # 考虑p中下一字符
            j, i = j+1, i+1
        else:                   # 失败！考虑pnext决定的下一字符
            i = pnext[i]
    if i==m:                    # 找到匹配，返回其下标   
        return j-1 
    return -1                   # 无匹配，返回特殊值
def gen_pnext(p):
    '''生成针对p种各位置i的下一检查位置表，用于KMP算法'''
    i, k, m = 0, -1, len(p)
    pnext = [-1]*m 
    while i < m-1:      # 生成下一个pnext元素
        if k==-1 or p[i]==p[k]:
            i, k = i+1, k+1 
            if p[i] ==p[k]:
                pnext[i] = pnext[k]
            else:
                pnext[i] = k 
        else:
            k = pnext[k]
    return pnext
print('ababcabcacbab', 'abcac', gen_pnext('abbcabcaabbcaa'))