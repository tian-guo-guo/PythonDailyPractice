from LCList import LCList

'''
问题：
假设有n个人围坐一圈，现在要求从第k个人开始报数，报到第m个数的人退出。
然后从下一个人开始继续报数并按同样规则退出，直至所有人退出。
要求按顺序输出各出列人的编号。
'''

# method 1: 基于“数组”概念的解法
'''
    把list看作元素个数固定的对象，只修改元素的值，不改变表的结构(不用加入或删除元
素的操作)。这相当于摆了一圈n把椅子，人可以走但椅子在那里且位置不变。基于这种设计
可以有多种实现方法。下面的方法是给每个人赋予一个编号，没有人的情况用0表示，各list
的元素记录这些编号。
算法梗概:
    ●初始:
        O建立一个包含n个人(的编号)的表。
        O找到第k个人，从那里开始。
    ●处理过程中采用把相应表元素修改为0的方式表示已出列，反复做:
        O数m个(尚在坐的)人，遇到表的末端就转回下标0继续。
        O把表示第m个人的表元素修改为0。
    ●n个人出列即结束。
    下面算法里用i表示数组下标，其初值取k-1,内层循环中每次加一并通过取模n保持i的
取值范围正确。大循环-次迭代出列一人，共计执行n次迭代。循环体里的count计数直至
m (通过内层循环)，计数中跳过空椅子。其他部分都很容易理解。
'''
def josephus_A(n, k, m):
    people = list(range(1, n+1))
    i = k - 1 
    for num in range(n):
        count = 0 
        while count < m:
            if people[i] > 0: 
                count += 1 
            if count == m: 
                print(people[i], end='')
                people[i] = 0 
            i = (i + 1) % n 
        if num < n-1:
            print(', ', end='')
        else:
            print('')
    return 

# method 2: 基于顺序表的解
'''
    现在考虑另-个算法:把保存人员编号的list按表的方式处理，一旦确定了应该退出的
人，就将表示其编号的表元素从表中删除。
    这样，随着计算的进行，所用的表将变得越来越短。下面用num表示表的长度，每退出
一人，表的长度num减一，至表长度为0时计算工作结束。采用这种想法和设计，表中的元
素全是有效元素(不再出现表示没人的0)，元素计数与下标计数得到统-， 所以下标更新可以
用i=(i+m-1)%  num统-描述。
'''
def josephus_L(n, k, m):
    people = list(range(1, n+1))
    num, i = n, k-1
    for num in range(n, 0, -1):
        i = (i + m-1) % num 
        print(people.pop(i),
              end=(', ' if num > 1 else '\n'))
    return 

# method3: 基于循环单链表的解
'''
    现在考虑基于循环单链表实现一个算法。
    从形式上看，循环单链表可以很直观地表示围坐-圈的人，顺序数人头可以自然地反映为
在循环表中沿着next链扫描，一个人退出可以用删除相应结点的操作模拟。在这样做之后,
又可以沿着原方向继续数人头了。
    根据上面分析，这个算法应该分为两个阶段: 
    1)建立包含指定个数(和内容)的结点的循环单链表，这件事可以通过从空表出发，在
尾部逐个加入元素的方式完成。
    2)循环计数，找到并删除应该退出的结点。
    具体实现可以有多种方式，例如:为原循环单链表增加-一个循环数数的函数,然后写一段程序
建立所需的循环单链表，并完成操作。下面的实现采用了另-种方式，即基于循环单链表类派
生出一个专门的类，用其初始化方法完成全部工作。
    派生类Josephus的实现中没有增加“当前人指针”一类设置，采用了另一种考虑，把
计数过程看作人圈的转动(结点环的转动)。这个类里定义了新方法turn,它将循环表对象的
rear指针沿next方向移m步(相当于结点环旋转)。
    这个类的初始化函数首先调用基类LCList的初始化函数建立一个空表， 然后通过-个循
环建立包含n个结点和相应数据的初始循环表。最后的循环反复调用turn方法，找到并逐个
弹出结点，输出结点里保存的编号。
'''
class Josephus(LCList):
    def turn(self, m):
        for i in range(m):
            self._rear = self._rear.next 
    def __init__(self, n, k, m):
        LCList.__init__(self)
        for i in range(n):
            self.append(i+1)
        self.turn(k-1)
        while not self.is_empty():
            self.turn(m-1)
            print(self.pop(),
                  end=('\n' if self.is_empty() else ', '))

res1 = josephus_A(10, 2, 7)
print(res1)
res2 = josephus_L(10, 2, 7)
print(res2)
res3 = Josephus(10, 2, 7)
print(res3)
